并行数据处理与性能
{
    用并行流并行处理数据
    并行流的性能分析
    分支/合并框架
    使用Spliterator分割流
}

*并行流
    -配置并行流使用的线程池
    并行流内部使用了默认的ForkJoinPool，它默认的线程数量就是处理器数量，这个值是由Runtime.getRuntime().availableProcessors()得到的。
    但是可以通过系统属性java.util.concurrent.ForJoinPool.common.parallelism来改变线程池的大小：
    System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism","12");
    这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个并行流指定这个值。一般而言，让ForkJoinPool的大小等于处理器
    数量是个不错的默认值，一般不建议修改它。

    -高效使用并行流

    一般而言，想给出任何关于什么时候该用并行流的定量建议都是不可能也是毫无意义的，因为任何类似于“仅当至少有一千个（或一百万个或随便什么数字）元
    素的时候才使用并行流”的建议对于某台特定机器上的某个特定操作可能都是对的，但在略有差异的另一种情况下可能就是大错特错。尽管如此，至少可以提出
    一些定性建议，帮助决定某个特定情况下是否有必要使用并行流。

    。如果有疑问，测量。把顺序流转成并行流轻而易举，但却不一定是好事。在这个章节部分，已经指出，并行流并不总比顺序流块。此外，并行流有时候会和你
    的直觉不一致，所以在考虑选择顺序流还是并行流，第一个也是最重要的建议就是用适当的基准来检测其性能。
    。留意装箱。自动装箱和拆箱操作会大大降低性能。Java8中有原始类型流（IntStream、LongStream、DoubleStream）来避免这种操作，但凡有可能都
    应用这些流。
    。有些操作本身在并行流上的性能的代价就很大。特别是limit和findFirst等依赖于元素顺序的操作，它们在并行流上执行的代价非常大。例如，findAny
    会比findFirst性能好，因为它不一定要按顺序来执行。你总是可以调用unordered方法来把有序流变成无序流。那么，如果需要流中的n个元素而不是专门
    要前n个的话，对于无序并行流调用limit可能会比单个有序流更高效。
    。还要考虑流的操作流水线的总计算成本。设N是要处理的元素总数，Q是一个元素通过流水线的大致处理成本，则N*Q就是对这个对成本的一个粗略估计。Q值
    高就意味着使用并行流时性能好的可能性比较大
    。对于较小的数据量，选择并行流几乎从来都不是一个好的决定。并行处理少数几个元素的好处还抵不上并行造成的额外开销。
    。要考虑流背后的数据结构是否易于分解。例如，ArrayList的拆分效率就比LinkedList高的多，因为前者用不着遍历就可以平均拆分，而后者则必须遍历。
    另外，用range工厂方法创建的原始类型流也可以快速分解。最后，可以自己实现Spliterator来完全掌控分解过程
    。流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能。例如，一个SIZED流可以分成大小相等的两个部分，这样每个部分都
    可以比较高效的并行处理，但筛选操作可能丢弃的元素个数却无法预测，导致流本身的大小未知
    。还要考虑终端操作中合并步骤的代价是大是小（例如Collector中的combiner方法）。如果这一步的代价很大，那么组合每个子流产生的部分结果所付出的
    代价就可能超过通过并行流得到的性能提升。

    下面表按照可分解行总结了一些流数据源适不适合并行：
    --------------------------------------------------------------------------------
    流的数据源和可分解性
    --------------------------------------------------------------------------------
    源                                              可分解性
    --------------------------------------------------------------------------------
    ArrayList                                       极佳
    --------------------------------------------------------------------------------
    LinkedList                                      差
    --------------------------------------------------------------------------------
    IntStream.range                                 极佳
    --------------------------------------------------------------------------------
    Stream.iterate                                  差
    --------------------------------------------------------------------------------
    HashSet                                         好
    ---------------------------------------------------------------------------------
    TreeSet                                         好
    --------------------------------------------------------------------------------

    最后，强调并行流背后使用的基础架构是Java7中引入的分支/合并框架。


*分支/合并框架
    分支/合并框架的目的是以递归的方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果。它是ExecutorService接口的
    一个实现，它把子任务分配给线程池（称为ForkJoinPool）中的工作线程。

    -使用RecursiveTask
    要把任务提交到这个池，必须创建RecursiveTask<R>的一个子类，其中R是并行化任务（以及所有子任务）产生的结果类型，或者如果任务不返回结果，则
    是RecursiveAction类型（当然它可能会更新其他非局部机构）。要定义RecursiveTask，只需实现它的唯一抽象方法compute:

    protected abstract R compute();

    这个方法同时定义了将任务拆分成子任务的逻辑，以及无法再拆分或不方便再拆分时，生成单个子任务的逻辑。所以，这个方法的实现类似于下面的伪代码：

    if (任务足够小或不可分) {
        顺序计算该任务
    } else {
        将任务分成两个子任务
        递归调用本方法，拆分每个子任务，等待所有子任务完成
    }

    -使用分支/合并框架的最佳做法
    。对一个任务调用join方法会阻塞调用方，直到该任务做出结果。因此，有必要在两个子任务的计算都开始之后再调用它。否则，得到的版本会比原始的顺序
    算法更慢更复杂，因此每个子任务都必须等待另一个子任务完成才能启动。
    。不应该再RecursiveTask内部使用ForkJoinPool的invoke方法。相反，应该始终直接调用compute或fork方法，只有顺序代码才应该用invoke来启动
    并行计算。
    。对子任务调用fork方法可以把它排进ForkJoinPool。同时对左边和右边的子任务调用它似乎很自然，但这样做的效率要比直接对其中一个调用compute低
    这样做可以为其中一个子任务重用同一个线程，从而避免再线程池中多分配一个任务造成的开销。
    。调试使用分支/合并框架的并行计算可能有些棘手。特别是IDE里看栈跟踪来找问题，但放在分支/合并计算上就不行了，因为调用compute的线程并不是概念
    上的调用方，后者是调用fork的那个。
    。和并行流一样，不是理所当然的认为在多核处理器上使用分支/合并框架就比顺序计算快。一个任务可以分解成多个独立的子任务，才能让性能在并行化时有
    提升。

    -工作窃取
    分出大量的小任务一般来说是一个很好的选择，因为，理想情况下，划分并行任务，希望每个任务都用完全相同的时间完成，让所有CPU内核都同样繁忙。但是
    实际情况，每个子任务所花的时间可能天差地别。
    所以，分支/合并框架用一种称为“工作窃取”的技术来解决这个问题。比如，某个线程可能早早完成了分配给它的任务，这时它的队列是空的，而其他线程还很
    忙。这是，这个线程会随机选一个别的线程，从队列尾部“偷走”一个任务。这个过程一直继续下去，直到所有任务都执行完毕，所有队列都清空。
    这就是，为什么要划分多个小任务，而不是少数几个大任务，这有助于工作线程之间平衡负载。

    在Fork/Join的例子中，明确指定了将数字数组拆分成多个任务单元的逻辑，但是，使用并行流时就不用这么做了，这是因为有一种自动机制Spliterator来
    拆分流。



*Spliterator
    Spliterator是Java8中加入的另一个新接口；这个名字代表“可分迭代器”（splitable iterator）。和Iterator一样，Spliterator也用于遍历数
    据源中的元素，但它是为了并行执行而设计的。Java8已经为集合框架中包含的所有数据结构提供了一个默认的Spliterator实现。

    public interface Spliterator<T> {
        boolean tryAdvance(Consumer<? super T> action);
        Spliterator<T> trySplit();
        long estimateSize();
        int characteristics();
    }
    T是Spliterator遍历的元素的类型。tryAdvance方法的行为类似于普通的Iterator，因为它会按顺序一个一个使用Spliterator中的元素，并且如果还
    有其他元素要遍历就返回true。但trySplit是专为Spliterator接口设计的，因为它可以把一些元素划出去分给第二个Spliterator（由该方法返回），
    让它们两个并行处理。Spliterator还可以通过estimateSize方法估计还剩多少个元素要遍历，即使不那么确切，能快速算出来一个值也有助于让拆分均匀

    -拆分过程
    将Stream拆分成多个部分的算法是一个递归的过程。第一步是对第一个Spliterator调用trySplit，生成第二个Spliterator。第二步对这两个
    Spliterator调用trySplit，这样总共就有四个Spliterator。这个框架不断对Spliterator调用trySplit直到它返回null，表明它处理的数据结构不
    能再分割。最后，所有的Spliterator再调用trySplit时都返回null。

    这个拆分过程也受Spliterator本身的特性影响，而特性是通过characteristics方法声明的。

    ----------------------------------------------------------------------------------------
    Spliterator的特性
    -----------------------------------------------------------------------------------------
    ORDERED         元素有既定的顺序（如List），因此Spliterator在遍历和划分时也会遵循这个顺序
    -----------------------------------------------------------------------------------------
    DISTINCT        对于任意一对遍历过的元素x和y，x.equals(y)返回false
    -----------------------------------------------------------------------------------------
    SORTED          遍历的元素按照一个预定义的顺序排序
    ------------------------------------------------------------------------------------------
    SIZED           该Spliterator由一个已知大小的源建立（例如Set），因此estimatedSized()返回的是准确值
    ------------------------------------------------------------------------------------------
    NONNULL         保证遍历的元素不会为null
    ------------------------------------------------------------------------------------------
    IMMUTABLE       Spliterator的数据源不能修改，意味着在遍历时不能添加、删除或修改元素
    -----------------------------------------------------------------------------------------
    CONCURRENT      该Spliterator的数据源可以被其他线程同时修改而无需同步
    ----------------------------------------------------------------------------------------
    SUBSIZED        该Spliterator和所有从它拆分出来的Spliterator都是SIZED
    ----------------------------------------------------------------------------------------