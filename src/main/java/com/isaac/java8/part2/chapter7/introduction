并行数据处理与性能
{
    用并行流并行处理数据
    并行流的性能分析
    分支/合并框架
    使用Spliterator分割流
}

*并行流
    -配置并行流使用的线程池
    并行流内部使用了默认的ForkJoinPool，它默认的线程数量就是处理器数量，这个值是由Runtime.getRuntime().availableProcessors()得到的。
    但是可以通过系统属性java.util.concurrent.ForJoinPool.common.parallelism来改变线程池的大小：
    System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism","12");
    这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个并行流指定这个值。一般而言，让ForkJoinPool的大小等于处理器
    数量是个不错的默认值，一般不建议修改它。

    -高效使用并行流

    一般而言，想给出任何关于什么时候该用并行流的定量建议都是不可能也是毫无意义的，因为任何类似于“仅当至少有一千个（或一百万个或随便什么数字）元
    素的时候才使用并行流”的建议对于某台特定机器上的某个特定操作可能都是对的，但在略有差异的另一种情况下可能就是大错特错。尽管如此，至少可以提出
    一些定性建议，帮助决定某个特定情况下是否有必要使用并行流。

    。如果有疑问，测量。把顺序流转成并行流轻而易举，但却不一定是好事。在这个章节部分，已经指出，并行流并不总比顺序流块。此外，并行流有时候会和你
    的直觉不一致，所以在考虑选择顺序流还是并行流，第一个也是最重要的建议就是用适当的基准来检测其性能。
    。留意装箱。自动装箱和拆箱操作会大大降低性能。Java8中有原始类型流（IntStream、LongStream、DoubleStream）来避免这种操作，但凡有可能都
    应用这些流。
    。有些操作本身在并行流上的性能的代价就很大。特别是limit和findFirst等依赖于元素顺序的操作，它们在并行流上执行的代价非常大。例如，findAny
    会比findFirst性能好，因为它不一定要按顺序来执行。你总是可以调用unordered方法来把有序流变成无序流。那么，如果需要流中的n个元素而不是专门
    要前n个的话，对于无序并行流调用limit可能会比单个有序流更高效。
    。还要考虑流的操作流水线的总计算成本。设N是要处理的元素总数，Q是一个元素通过流水线的大致处理成本，则N*Q就是对这个对成本的一个粗略估计。Q值
    高就意味着使用并行流时性能好的可能性比较大
    。对于较小的数据量，选择并行流几乎从来都不是一个好的决定。并行处理少数几个元素的好处还抵不上并行造成的额外开销。
    。要考虑流背后的数据结构是否易于分解。例如，ArrayList的拆分效率就比LinkedList高的多，因为前者用不着遍历就可以平均拆分，而后者则必须遍历。
    另外，用range工厂方法创建的原始类型流也可以快速分解。最后，可以自己实现Spliterator来完全掌控分解过程
    。流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能。例如，一个SIZED流可以分成大小相等的两个部分，这样每个部分都
    可以比较高效的并行处理，但筛选操作可能丢弃的元素个数却无法预测，导致流本身的大小未知
    。还要考虑终端操作中合并步骤的代价是大是小（例如Collector中的combiner方法）。如果这一步的代价很大，那么组合每个子流产生的部分结果所付出的
    代价就可能超过通过并行流得到的性能提升。

    下面表按照可分解行总结了一些流数据源适不适合并行：
    --------------------------------------------------------------------------------
    流的数据源和可分解性
    --------------------------------------------------------------------------------
    源                                              可分解性
    --------------------------------------------------------------------------------
    ArrayList                                       极佳
    --------------------------------------------------------------------------------
    LinkedList                                      差
    --------------------------------------------------------------------------------
    IntStream.range                                 极佳
    --------------------------------------------------------------------------------
    Stream.iterate                                  差
    --------------------------------------------------------------------------------
    HashSet                                         好
    ---------------------------------------------------------------------------------
    TreeSet                                         好
    --------------------------------------------------------------------------------

    最后，强调并行流背后使用的基础架构是Java7中引入的分支/合并框架。


*分支/合并框架
    分支/合并框架的目的是以递归的方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果。它是ExecutorService接口的
    一个实现，它把子任务分配给线程池（称为ForkJoinPool）中的工作线程。

    -使用RecursiveTask
    要把任务提交到这个池，必须创建RecursiveTask<R>的一个子类，其中R是并行化任务（以及所有子任务）产生的结果类型，或者如果任务不返回结果，则
    是RecursiveAction类型（当然它可能会更新其他非局部机构）。要定义RecursiveTask，只需实现它的唯一抽象方法compute:

    protected abstract R compute();

    这个方法同时定义了将任务拆分成子任务的逻辑，以及无法再拆分或不方便再拆分时，生成单个子任务的逻辑。所以，这个方法的实现类似于下面的伪代码：

    if (任务足够小或不可分) {
        顺序计算该任务
    } else {
        将任务分成两个子任务
        递归调用本方法，拆分每个子任务，等待所有子任务完成
    }