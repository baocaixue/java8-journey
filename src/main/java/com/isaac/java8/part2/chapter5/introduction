使用流
{
    筛选、切片和匹配
    查找、匹配和归约
    使用数值范围等数值流
    从多个源创建流
    无限流
}

*Stream的map和flatMap

*归约
    不同于这样的终端操作：返回一个boolean（allMatch之类的）、void（forEach）或Optional对象（findAny等）。
    使用reduce操作来表达更复杂的查询，比如“计算菜单中的总卡路里”或“菜单中卡路里最高的菜”。此类查询需要将流中所有元素反复结合起来，得到一个值
    比如一个Integer。这样的查询可以被归类为归约操作（将流归约成一个值）。


*归约方法的优势与并行化
    相比之前的逐步迭代求和，使用reduce的好处在于，这里的迭代被内部迭代抽象掉了，这让内部实现得以选择并行执行reduce操作。而迭代式求和例子要更
    新共享变量sum，这不是那么容易并行化的。如果加入了同步，很可能会发现线程竞争抵消了并行本应带来的性能提升。这种计算的并行化需要另一种办法：将
    输入分块，分块求和，最后再合并起来。但这样代码看起来就完全不一样了。（参考分支/合并框架实现）
    需要认识到，可变的累加器模式对于并行化来说是死路一条，需要一种新的模式，这正是reduce所提供的。使用流对所有元素并行求和时，代码几乎不用修改
    ：stream（）换成了parallelStream（）。
    int sum = numbers.parallelStream().reduce(0, Integer::sum);
    但是，并行执行这段代码也要付出一定的代价，传递给reduce的Lambda不能更改状态（如实例变量），而且操作必须满足结合律才可以按任意顺序执行


*原始类型流特化
    java8引入了三个原始类型特化流接口：IntStream、DoubleStream和LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的
    装箱成本。每个接口都带来了进行常用数值归约的新方法，比如对数值流求和的sum，找最大元素的max。此外还有在必要时候再转回对象流的方法。
