来自函数式编程的其他好思想

    Java中从函数式编程引入了两个核心思想：将方法和Lambda作为一等值，以及在没有可变共享状态时，函数或方法可以有效、安全地并行执行。新的Stream
    API把这两种思想都用到了。

    常见的函数式语言，如SML、OCaml、Haskell，还提供了进一步的结构来帮助开发。其中之一就是通过使用更多的描述性数据类型来避免null。

    在Java8里有一个Optional<T>类，如果能一致地使用它的话，就可以帮助避免NullPointerException。它是一个容器对象，可以包含，也可以不包含一
    个值。Optional<T>中有方法来明确处理值不存在的情况，这样就可以避免NullPointerException。换句话说，它使用类型系统，允许表明我们知道一个
    变量可能会没有值。

    第二个想法是（结构）模式匹配。这在数学中也有使用，例如：
    f(0) = 1
    f(n) = n*f(n-1) otherwise

    在Java中，可以这里写一个if-then-else或一个switch语句。其他语言表明，对于更复杂的数据类型，模式匹配可以比if-then-else更简明地表达编程
    思想。对于这种数据类型，可以使用多态和方法重载来替代if-then-else，但对于那种方式更合适，就语言设计而言仍有一些争论。但两者都是有用的工具。
    不幸的是，Java8对模式匹配的支持并不完全，在chapter14会介绍如何对其进行表达。与此同时，会用Scala语言表达的例子加以描述。

    例如，要写一个程序对描述算术表达式的树做基本的简化，给定一个数据类型Expr代表这样的表达式，在Scala里可以写以下代码，把Expr分解给它的各个部
    分，然后返回另一个Expr：

    def simplifyExpression(expr: Expr): Expr = expr match{
        case BinOp("+", e, Number(0)) => e//加0
        case BinOp("*", e, Number(0)) => e//乘1
        case BinOp("/", e, Number(0)) => e//除1
        case _ => expr//不能简化expr
    }

    这里，Scala语法expr match就对应于Java中的switch(expr)。现在，对模式匹配可以看作switch的扩展形式，可以同时将一个数据类型分解成元素。

    为什么Java中的switch语句应该限于原始类型和String呢？函数式语言倾向于允许switch用在更多的数据类型上，包括允许模式匹配（在Scala中是通过
    match操作实现的）。在面向对象设计中，常用的访客模式可以用来遍历一组类（如汽车的不同组件：车轮、发动机、底盘等），并对每个访问的对象执行操
    作。匹配模式的一个优点是编译器可以报告常见的错误，如”Brakes类属于用来表示Car类的组件的一族类。你忘记了要显示处理它“。

    Total：
        Java8青睐函数式编程-->函数式编程的几个重要思想（方法&&Lambda作为一等公民、程序执行元素间无互动&&并行、通过描述性数据类型避免null、
    结构模式匹配（switch参数用更复杂的类型））-->Scala

    这部分描述了Java8的一个大体脉络，以及在编程语言领域学习其他编程思想的愿景与实现